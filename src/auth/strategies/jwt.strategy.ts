import { ConfigService } from '@nestjs/config'
import { ExtractJwt, Strategy } from 'passport-jwt'
import { PassportStrategy } from '@nestjs/passport'
import { Injectable } from '@nestjs/common'
import { IUser } from 'src/types/types'

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private readonly configService: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: configService.get('JWT_SECRET'),
    })
  }

  async validate(user: IUser) {
    return { id: user.id, email: user.email }
  }
  /* async validate(user: IUser) {
    if (user.id) {
      return { id: user.id, email: user.email }
    } else {
      return { email: user.email }
    }
  } */
}

/* constructor(private readonly configService: ConfigService):

В конструкторе стратегии происходит инициализация с использованием super(), где передаются параметры для настройки стратегии.
jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(): указывает, что токен будет извлекаться из заголовка Authorization в формате Bearer Token.
ignoreExpiration: false: говорит стратегии не игнорировать срок действия токена.
secretOrKey: configService.get('JWT_SECRET'): указывает секретный ключ для проверки подписи токена. Ключ берется из конфигурации вашего приложения, в данном случае, с использованием ConfigService.
async validate(user: IUser):

Метод validate вызывается, когда стратегия успешно проверила токен и извлекла из него информацию о пользователе.
В данном случае, он возвращает объект с id и email пользователя. Эти данные будут доступны в объекте запроса в методе контроллера, к которому применен этот гвард.
Использование в контроллере:

Применение стратегии к контроллеру или методу выполняется с использованием @UseGuards(JwtStrategy), как вы видели в предыдущих примерах.
Таким образом, JwtStrategy обеспечивает проверку JWT-токена, его извлечение и валидацию, а также предоставляет информацию о пользователе для дальнейшего использования в вашем приложении.

Да, метод validate вызывается автоматически при использовании стратегии аутентификации в NestJS. Этот метод представляет собой функцию обратного вызова (callback), которую Passport.js вызывает, когда стратегия успешно извлекает и проверяет информацию об аутентификации из токена.

В примере с JwtStrategy, после успешной аутентификации и проверки токена этот метод возвращает объект с данными пользователя. После этого, эти данные становятся доступными в объекте запроса (req.user), когда используется гвард или стратегия аутентификации в контроллере.

В данном контексте, аргумент user представляет собой информацию о пользователе, которая была извлечена из JWT-токена в процессе аутентификации. Когда пользователь предоставляет валидный JWT-токен, Passport.js (используемый в NestJS) извлекает информацию из этого токена и передает ее в метод validate.

Таким образом, объект user в этом методе содержит информацию, которая была в токене. Обычно, в контексте аутентификации с использованием JWT, этот объект может содержать, например, поля id, email и другие атрибуты пользователя.*/

/*  конструктор служит для инъекции зависимости ConfigService в класс JwtStrategy, что позволяет классу использовать этот сервис для получения конфигурационных данных, таких как секретный ключ для JWT токенов. 

Проблема в том, что внутри конструктора класса JwtStrategy вы не имеете прямого доступа к зависимостям, таким как configService. Конструктор класса вызывается при создании экземпляра объекта, и в этот момент инъекция зависимостей ещё не произошла.

В NestJS инъекция зависимостей происходит в методе жизненного цикла, таком как onModuleInit или onModuleBootstrap, когда все зависимости уже готовы к использованию. Внутри конструктора вы не можете использовать инъекцию зависимостей напрямую.

Чтобы решить эту проблему, лучше всего инъектировать зависимости через конструктор. */
